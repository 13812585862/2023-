1.深拷贝实现
  hh() {
      let obj = {
        a: 1,
        b: function() {},
        c: [
          {
            d: 1,
            e: { f: 3 }
          }
        ],
        g: null,
        j: undefined
      }

      const ss = this.DeepClone(obj)
      ss.c[0].d = 'hhhhhh'
      console.log('see', ss, obj === ss, ss.c[0].d, obj.c[0].d)
    },
    DeepClone(source) {
      let target = Array.isArray(source) ? [] : {}
      if (typeof source === 'object') {
        for (let key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            if (source[key] && typeof source[key] === 'object') {
              target[key] = this.DeepClone(source[key])
            } else {
              target[key] = source[key]
            }
          }
        }
      }
      return target
    },
2.函数科里化
curry(fn) {
      const len = fn.length //形参个数
      return function t() {
        let gs = arguments.length //实参个数
        let args = Array.prototype.slice.call(arguments) //伪数组转化为数组
        if (gs >= len) {
          return fn.apply(undefined, args)
        } else {
          return function() {
            const newArgs = args.concat(Array.prototype.slice.call(arguments))
            return t.apply(undefined, newArgs)
          }
        }
      }
    },
    add(a, b, c, d, e) {
      return a + b + c + d + e
    },
    sf() {
      const finallFun = this.curry(this.add)
      const result1 = finallFun(1)(2)(3)(4)(5)
      const result2 = finallFun(1, 2)(3, 4)(5)
      const result3 = finallFun(1)(2)(3)(4)(5)(6)
      console.log(result1, result2, result3)
    },
